---
phase: 03-performance-seo
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - components/Navigation.vue
  - pages/index.vue
  - app.config.ts
  - assets/css/main.css
autonomous: true
requirements:
  - PERF-01
  - PERF-02

must_haves:
  truths:
    - "Navigation scroll handler uses passive event listener and position caching for INP optimization"
    - "Hero image has preconnect link hint for faster LCP"
    - "Font loading strategy prevents layout shift (CLS)"
    - "Critical CSS is inlined for faster FCP"
    - "Page has measurable Core Web Vitals improvement over baseline"
  artifacts:
    - path: "components/Navigation.vue"
      provides: "Optimized scroll handler with passive listener and cached positions"
      min_lines: 80
      contains: "passive.*true|sectionPositions"
    - path: "pages/index.vue"
      provides: "Preconnect hints and font optimization"
      contains: "preconnect|font-display"
    - path: "assets/css/main.css"
      provides: "Critical CSS with font loading optimization"
      contains: "@font-face|font-display"
  key_links:
    - from: "components/Navigation.vue"
      to: "window.addEventListener"
      via: "passive event listener option"
      pattern: "addEventListener.*scroll.*passive"
    - from: "pages/index.vue"
      to: "components/HeroSection.vue"
      via: "preconnect to image domain for LCP"
      pattern: "preconnect.*images"
---

<objective>
Optimize Core Web Vitals (LCP, INP, CLS) through scroll handler debouncing, image preloading hints, and font loading optimization to achieve passing scores.

Purpose: Current scroll handler in Navigation.vue reads offsetTop on every scroll event (layout thrashing), and no preconnect hints exist for the LCP image. These optimizations directly improve INP and LCP metrics.

Output: Optimized scroll handler with cached positions and passive listeners, preconnect hints for LCP resources, and font loading strategy to prevent CLS.
</objective>

<execution_context>
@/home/deck/.claude/get-shit-done/workflows/execute-plan.md
@/home/deck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-performance-seo/03-RESEARCH.md
@.planning/phases/03-performance-seo/03-01-SUMMARY.md
@.planning/phases/01-foundation-compliance/01-02-SUMMARY.md
@components/Navigation.vue
@pages/index.vue
@assets/css/main.css

# Current Performance Issues from Research
From 03-RESEARCH.md section on INP Optimization:
- Navigation.vue scroll handler (lines 51-70) reads element.offsetTop on every scroll
- This triggers layout recalculation, causing layout thrashing
- Solution: Cache section positions on mount, use passive event listener

# LCP Optimization Strategy
From 03-RESEARCH.md section on LCP Optimization:
- Hero image is the LCP element (largest contentful paint)
- Add preconnect hints for faster image loading
- Preload hero image with higher priority

# Font Loading for CLS Prevention
From 03-RESEARCH.md section on CLS Optimization:
- Use font-display: swap to prevent invisible text
- Add preconnect to fonts.googleapis.com

# Current Navigation.vue Scroll Handler (lines 51-70)
```typescript
const updateScrollState = () => {
  isScrolled.value = window.scrollY > 50
  const scrollPosition = window.scrollY + 100

  for (const section of sections) {
    const element = document.getElementById(section.id)
    if (element) {
      const top = element.offsetTop  // LAYOUT TRIGGER!
      const bottom = top + element.offsetHeight
      if (scrollPosition >= top && scrollPosition < bottom) {
        activeSection.value = section.id
        break
      }
    }
  }
}

onMounted(() => {
  window.addEventListener('scroll', updateScrollState)  // NO passive option
  updateScrollState()
})
```

# Expected Metrics (from research)
- LCP target: < 2.5s
- INP target: < 200ms
- CLS target: < 0.1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Optimize Navigation.vue scroll handler for INP</name>
  <files>components/Navigation.vue</files>
  <action>
Update components/Navigation.vue to optimize the scroll handler:

1. Add a sectionPositions ref to cache offsetTop values (after the sections array definition):
   ```typescript
   // Cache section positions to avoid layout thrashing
   const sectionPositions = ref<Map<string, number>>(new Map())
   ```

2. Create a cacheSectionPositions function (before updateScrollState):
   ```typescript
   // Cache section positions once on mount to avoid reading offsetTop during scroll
   const cacheSectionPositions = () => {
     const positions = new Map<string, number>()
     for (const section of sections) {
       const element = document.getElementById(section.id)
       if (element) {
         positions.set(section.id, element.offsetTop)
       }
     }
     sectionPositions.value = positions
   }
   ```

3. Update updateScrollState to use cached positions (replace entire function):
   ```typescript
   // Update scroll state and active section using cached positions
   const updateScrollState = () => {
     // Update isScrolled state for shadow effect
     isScrolled.value = window.scrollY > 50

     // Update active section using cached positions (no layout thrashing)
     const scrollPosition = window.scrollY + 100 // Offset for nav height

     for (const section of sections) {
       const top = sectionPositions.value.get(section.id) ?? 0
       const element = document.getElementById(section.id)
       const bottom = element ? top + element.offsetHeight : top + 1000

       if (scrollPosition >= top && scrollPosition < bottom) {
         activeSection.value = section.id
         break
       }
     }
   }
   ```

4. Update onMounted to cache positions and use passive listener:
   ```typescript
   onMounted(() => {
     // Cache section positions once
     cacheSectionPositions()
     // Add scroll event listener with passive option for better INP
     window.addEventListener('scroll', updateScrollState, { passive: true })
     // Initial call to set active section on page load
     updateScrollState()
   })
   ```

5. Update onBeforeUnmount cleanup:
   ```typescript
   onBeforeUnmount(() => {
     // Cleanup scroll event listener
     window.removeEventListener('scroll', updateScrollState)
   })
   ```

Key optimizations:
- Caches offsetTop values once on mount (no layout reads during scroll)
- Uses { passive: true } for better scroll performance (INP improvement)
- Maintains same functionality with better performance
  </action>
  <verify>
    Navigation.vue contains sectionPositions ref, cacheSectionPositions function, updateScrollState uses cached positions (not offsetTop), and addEventListener has { passive: true } option.
  </verify>
  <done>
    Navigation scroll handler caches positions on mount and uses passive event listener, eliminating layout thrashing during scroll for improved INP scores.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add preconnect hints and SEO meta tags to index.vue</name>
  <files>pages/index.vue</files>
  <action>
Update pages/index.vue to add performance preconnect hints and enhanced SEO meta tags:

1. Replace the existing useHead with an enhanced version:
   ```typescript
   useHead({
     title: 'Xzandria Armstrong for Houston County - Leadership for Our Community',
     meta: [
       { name: 'description', content: 'Leadership for Houston County, GA. Support Xzandria Armstrong\'s campaign for progress, integrity, and community.' },
       // Open Graph tags
       { property: 'og:type', content: 'website' },
       { property: 'og:site_name', content: 'Xzandria Armstrong for Houston County' },
       { property: 'og:title', content: 'Xzandria Armstrong for Houston County' },
       { property: 'og:description', content: 'Leadership for Houston County, GA. Support Xzandria Armstrong\'s campaign for progress, integrity, and community.' },
       { property: 'og:image', content: '/images/candidate-portrait.svg' },
       { property: 'og:url', content: 'https://armstrongforhouston.com/' },
       // Twitter Card
       { name: 'twitter:card', content: 'summary_large_image' },
       { name: 'twitter:title', content: 'Xzandria Armstrong for Houston County' },
       { name: 'twitter:description', content: 'Leadership for Houston County, GA. Support Xzandria Armstrong\'s campaign.' },
       { name: 'twitter:image', content: '/images/candidate-portrait.svg' }
     ],
     link: [
       { rel: 'canonical', href: 'https://armstrongforhouston.com/' }
     ]
   })
   ```

2. Add preconnect hints in the template (before any sections):
   ```vue
   <template>
     <!-- Performance resource hints -->
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

     <!-- Hero Section -->
     <section id="hero">
       <HeroSection />
     </section>
     <!-- ... rest of sections unchanged ... -->
   </template>
   ```

Note: The og:image uses the current SVG placeholder. Update to actual JPG path when real photo is available.

Preconnect hints warm up the connection to Google Fonts for faster font loading (CLS prevention). Enhanced meta tags improve SEO and social sharing.
  </action>
  <verify>
    pages/index.vue contains useHead with Open Graph and Twitter Card meta tags, canonical URL, and template has preconnect link hints for Google Fonts.
  </verify>
  <done>
    Homepage has enhanced SEO meta tags (Open Graph, Twitter Card, canonical) and preconnect hints for Google Fonts to improve font loading performance.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add font loading optimization to main.css</name>
  <files>assets/css/main.css</files>
  <action>
Add font loading optimization to assets/css/main.css:

1. Check if the file already has @font-face definitions
2. If using Google Fonts (which the site does via Tailwind), add font-display optimization:
   ```css
   /* Font loading optimization - use font-display: swap to prevent layout shift */
   @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

   /* Custom font with display swap */
   @font-face {
     font-family: 'Inter';
     font-style: normal;
     font-weight: 400 700;
     font-display: swap; /* Prevents invisible text during font load */
     src: local('Inter'), local('Inter-Regular');
   }
   ```

3. If the file already has font imports, just add the font-display: swap property

The font-display: swap property ensures text is visible immediately with fallback fonts, then swaps to the custom font when loaded. This prevents both FOIT (Flash of Invisible Text) and minimizes CLS.

If using a different font family than Inter, adjust accordingly. The key is font-display: swap.
  </action>
  <verify>
    assets/css/main.css contains @font-face with font-display: swap or @import with display=swap parameter.
  </verify>
  <done>
    Font loading strategy uses font-display: swap to prevent invisible text and minimize layout shift during font loading.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update app.config.ts with performance-related metadata</name>
  <files>app.config.ts</files>
  <action>
Update app.config.ts to add site configuration for canonical URLs and SEO:

1. The site property already exists in nuxt.config.ts, but verify app.config.ts has consistent configuration
2. If missing, add to app.config.ts:
   ```typescript
   export default defineAppConfig({
     site: {
       name: 'Xzandria Armstrong for Houston County',
       description: 'Leadership for Houston County, GA',
       url: 'https://armstrongforhouston.com'
     },
     // ... existing config
   })
   ```

This ensures consistent site metadata across components that use useAppConfig(). The @nuxtjs/seo module already uses nuxt.config.ts site configuration for sitemap and robots.txt generation.

If the site property already exists in app.config.ts, no changes needed — just verify the URL matches the production domain.
  </action>
  <verify>
    app.config.ts contains site property with name, description, and url matching nuxt.config.ts configuration.
  </verify>
  <done>
    Site metadata is consistently configured in app.config.ts for use across components and SEO modules.
  </done>
</task>

</tasks>

<verification>
Overall verification steps:

1. Build verification: Run `npm run generate` — site builds without errors
2. Navigation verification: Check components/Navigation.vue has sectionPositions caching and passive listener
3. Meta tags verification: View generated .output/public/index.html — should have Open Graph and Twitter Card tags
4. Preconnect hints: Generated HTML has <link rel="preconnect"> tags
5. Font optimization: main.css has font-display: swap
6. Lighthouse baseline: Run Lighthouse audit in Chrome DevTools and note scores (expect Performance 75+)
7. INP check: Scroll page smoothly — navigation highlights should update without jank
</verification>

<success_criteria>
1. Navigation scroll handler uses cached positions and passive event listener
2. Homepage has Open Graph, Twitter Card, and canonical meta tags
3. Preconnect hints for Google Fonts are present
4. Font loading uses font-display: swap
5. Lighthouse Performance score improves (baseline 75+ target)
6. Scroll interactions are smooth (no visible lag)
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-seo/03-02-SUMMARY.md` documenting:
- Scroll handler optimizations applied
- Meta tags added for SEO
- Preconnect and font loading improvements
- Lighthouse baseline scores (if measured)
- Time to complete
</output>
